# Philosophers

## 引数

1. number_of_philosophers
- 哲学者の人数（同時にスレッドを何個作るか）

- 2以上でなければ意味がない（1だと片方のフォークがなくて死ぬ）

2. time_to_die<-game
- 寿命（ミリ秒単位）

- 最後に食事をしてからこの時間が経過すると、その哲学者は「死亡」

- → gettimeofday などで「最後に食べた時間」を記録して監視スレッドがチェックする

3. time_to_eat<-game
- 食事時間（ms）

- 2本のフォークを取って「食事している」状態になる時間

- この間は「他の哲学者がそのフォークを使えない」

- 食べ終わったら「最後に食べた時刻」を更新

4. time_to_sleep<-game
- 睡眠時間（ms）

- 食べ終わった後、寝ている時間

- 寝ている間はフォークを離しているので他の哲学者が使える

5. [number_of_times_each_philosopher_must_eat]（オプション）
- 必須で食べる回数

- 全員がこの回数に到達したらプログラム終了

- 指定されない場合は「誰かが死ぬまで無限に続ける」


## ルール

「Philosophers（哲学者）」課題の ルール を整理して解説します。
課題で守るべき制約や動作の基本ルールを理解することが大事です。

1. 参加者
- 哲学者は N 人

    - 各哲学者は 1スレッド で表現

    - ID は 1 から N

- フォークは N 本

    - 円卓の各哲学者の左右に1本ずつ配置

    - 同時に1人しか持てない（mutex で保護）

2. 行動ループ
各哲学者は次の動作を繰り返します：

1. 考える (thinking)

- フォークを取っていない状態

- 思考中は他の哲学者に影響なし

2. フォークを取る

    - 左フォーク → 右フォーク（または逆）

    - フォークは mutex で保護

    - デッドロック回避のため、哲学者によって順番を変えることもある

3. 食べる (eating)

    - 2本のフォークを持っているときだけ可能

    - 食事時間は time_to_eat（ミリ秒）

    - 食べ終わったら 最後に食べた時刻を更新

4. フォークを置く

- 食事後は両方のフォークを解放（mutex unlock）

5. 眠る (sleeping)

- time_to_sleep の間、フォークは解放されたまま

- 睡眠中は他の哲学者がフォークを使える

3. 終了条件
- 誰かが time_to_die を超えて食べなかった → 死亡、プログラム終了

- （オプション）全員が指定回数食べ終わった → プログラム終了

4. 出力ルール
- 行動は タイムスタンプ + 哲学者ID + 状態 で出力

- 例：
``````c
123 1 has taken a fork
123 1 is eating
223 1 is sleeping
``````

- ログ出力も mutex で保護して競合を避ける

5. デッドロック回避
- 注意：全員が同時に左フォークを取ると永遠に待つ → デッドロック

- 対策例：

    - 偶数IDは左→右、奇数IDは右→左

    - 最大同時フォーク取得人数を N-1 に制限

6. 時間管理

- time_to_die の監視には 監視スレッド か ループでのチェック

- gettimeofday() でミリ秒単位の経過時間を取得

- usleep() で細かくスリープ


## 設計
- [x] 引数をatoiで処理,オプションの処理<-ifで分岐argc使う<-init関数の作成。
- [ ] 引数を受け取って、人数分thread作成<-init_thread
    - [ ] threadに通した関数でHelloworld出力

- [ ] ゲームフェーズ<-後で設計.

## 例外処理
